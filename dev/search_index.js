var documenterSearchIndex = {"docs":
[{"location":"contraction_order/#Tensor-Network-Contraction-Order-Optimization-with-Optimal-Tree-Decomposition","page":"Contraction Order","title":"Tensor Network Contraction Order Optimization with Optimal Tree Decomposition","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"This blog is a technical note for the Google Summer of Code 2024 project \"Tensor network contraction order optimization and visualization\" released by The Julia Language, where I developed a package TreeWidthSolver.jl for calculating the tree decomposition with minimal treewidth of a given simple graph and made it a backend of OMEinsumContracionOrders.jl.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"This blog covers the following contents:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Contraction order of tensor network\nTree decomposition and its relation to contraction order\nFinding tree decomposition with minimal treewidth","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"In this blog, we will use the Einsum notation from OMEinsum.jl.","category":"page"},{"location":"contraction_order/#Tensor-Network-Contraction-Order","page":"Contraction Order","title":"Tensor Network Contraction Order","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"In this blog, we will not introduce the basic concept of tensor network, since it has been well introduced in many other places. Instead, we recommend the following references:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"For readers with physics background: https://tensornetwork.org/diagrams/\nFor readers want to get a formal definition: Chapter 2 of https://epubs.siam.org/doi/abs/10.1137/22M1501787","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"For simplicity, in the following sections, we will use the Einstein summation formula to represent the tensor network as high dimensional arrays' multiplication: R_ijk = sum_a b c  A_aB_b It is easy to see that the most direct way to calculate the result is to loop over all the indices naively, which requires O(d^N) operations, where d is the dimension of the index and N is the number of indices. However, such a direct calculation is not efficient. Considering the following simple tensor network:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"(Image: )","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"where the tensors are represented by the circles and the indices are represented by the lines, representing the following contraction to scalar s: s = sum_ijkl A_ij B_ik C_jl D_lk and can be represented as the following Einstein summation formula:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"julia> using OMEinsum\n\njulia> einsum = ein\"ij, ik, jl, lk -> \"\nij, ik, jl, lk ->","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"where pointing to nothing means the result is a scalar. Here we simply assume that all indices are of the same dimension D. Then the naive way to calculate the result is to loop over all the indices, which requires O(D^4) operations and no intermediate tensors are produced.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"However, another way to calculate s is shown below:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"(Image: )","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"where we first contract A and B to get AB, and contract C and D to get CD, which are rank-2 intermediate tensors, and then contract AB with CD to get the scalar s. That is equivalent to the following Einstein summation formula:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"julia> nested_ein = ein\"(ij, ik), (jl, lk) -> \"\njk, jk ->\n├─ ij, ik -> jk\n│  ├─ ij\n│  └─ ik\n└─ jl, lk -> jk\n   ├─ jl\n   └─ lk","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"In this way, the total number of operations is O(2 D^3 + D^2), which is smaller than the naive calculation, while the trade-off is that we need to store the intermediate tensors AB and CD with size of O(D^2), as shown below:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"# here we take D = 16\njulia> size_dict = uniformsize(einsum, 2^4)\n\njulia> contraction_complexity(einsum, size_dict)\nTime complexity: 2^16.0\nSpace complexity: 2^0.0\nRead-write complexity: 2^10.001408194392809\n\njulia> contraction_complexity(nested_ein, size_dict)\nTime complexity: 2^13.044394119358454\nSpace complexity: 2^8.0\nRead-write complexity: 2^11.000704269011246","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"We say such a contraction is with time complexity of O(D^3) and space complexity of O(D^4), which are defined as follows:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"time complexity: the number of Floating Point operations required to calculate the result;\nspace complexity: the largest size of the intermediate tensors.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"For larger tensor networks, the contraction order is important, since it can greatly reduce the time complexity of the calculation.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"In actual calculation, we prefer binary contractions, i.e., contracting two tensors at a time, by converting these two tensors as matrices, so that we can make use of BLAS libraries to speed up the calculation. In this way, a given contraction order can be represented as a binary tree. The contraction tree can be represented as a rooted tree, where the leaves are the tensors to be contracted and the internal nodes are the intermediate tensors. The contraction tree corresponding to the above example is shown below:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"(Image: )","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Generally speaking, our target is to find a binary contraction order, with minimal time complexity or space complexity, which is called the optimal contraction order.","category":"page"},{"location":"contraction_order/#Tools-for-Tensor-Network-Contraction-Order-Optimization","page":"Contraction Order","title":"Tools for Tensor Network Contraction Order Optimization","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"In practice, there are many tools for tensor network contraction order optimization, including:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"OMEinsumContractionOrder.jl: an open-source Julia package for finding the optimal contraction order of tensor networks, is used as backend of OMEinsum.jl and ITensorNetworks.jl.\nCotengra : a python library for contracting tensor networks or einsum expressions involving large numbers of tensors.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Various methods have been proposed for optimizing the contraction order, as shown in the table below, here we introduce some of them.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Optimizer Description Available in\nExhaustive Search Slow, exact TensorOperations.jl\nGreedy Algorithm Fast, heuristic OMEinsumContractionOrders.jl, Cotengra\nBinary Partition Fast, heuristic OMEinsumContractionOrders.jl, Cotengra\nLocal Search Fast, heuristic OMEinsumContractionOrders.jl\nExact Treewidth Slow, exact OMEinsumContractionOrders.jl","category":"page"},{"location":"contraction_order/#Exhaustive-Search","page":"Contraction Order","title":"Exhaustive Search","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"The exhaustive search Robert is a method to get the exact optimal contraction complexity. There are three different ways to implement the exhaustive search:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Depth-first constructive approach: in each step, choose a pair of tensors to contract a new tensor until all tensors are contracted, and then iterate over all possible contraction sequences without duplication. Note the cheapest contraction sequence thus found.\nBreadth-first constructive approach: the breadth-first method construct the set of intermediate tensors by contracting c tensors (c in 1 n - 1, where n is the number of tensors) in each step, and record the optimal cost for constructing each intermediate tensor. Then in the last step, the optimal cost for contracting all n tensors is obtained.\nDynamic programming: in each step, consider all bipartition that split the tensor network into two parts, if the optimal cost for each part is not recorded, further split them until the cost has been already obtained or only one tensor is left. Then combine the two parts and record the optimal cost of contracting the sub-networks. In this end the optimal cost for the whole network is obtained.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"In more recent work Robert, by reordering the search process in favor of cheapest-first and excluding large numbers of outer product contractions which are shown to be unnecessary, the efficiency of the exhaustive search has been greatly improved. The method has been implemented in TensorOperations.jl.","category":"page"},{"location":"contraction_order/#Greedy-Algorithm","page":"Contraction Order","title":"Greedy Algorithm","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"The Greedy method is one of the simplest and fastest method for optimizing the contraction order. The idea is to greedily select the pair of tensors with the smallest cost to contract at each step. In each step, for all possible pairs of tensors, the cost of the contraction is evaluated, and the pair with the smallest cost is selected and then contracted, which forms a new tensor.  This process is repeated until all tensors are contracted. This method is fast, however it is easy to be trapped in local minima.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"An enhanced method is called the hyper-greedy method, where in each step one does not directly select the pair with the smallest cost, but instead samples according to the Boltzmann distribution given by mathcalP(v_i v_j) = e^-L(v_i v_j)  T, where L(v_i v_j) is the cost function. In this case, it is possible for the process to escape from local minima. Then we run this process multiple times and select the best result. The method has already been used in both OMEinsumContractionOrders.jl and Cotengra. ","category":"page"},{"location":"contraction_order/#Binary-Partition","page":"Contraction Order","title":"Binary Partition","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"A given tensor network can be regarded as a hypergraph, where the tensors are the vertices and the shared indices are the hyperedges, and the cost of contracting a hyper edge can be encoded as its weight. The binary partition method is to partition the hypergraph into two parts, and then recursively partition each part. Cost of each partition can be evaluated by the sum of the weights of the hyperedges cut by the partition, while we prefer to make the partition as balanced as possible (balance means size of the subgraph should be similar). Thus, the problem is reduced to a balanced min cut problem on a hypergraph. In the past few decades, the graph community has developed many algorithms for the balanced min cut problem and provided the corresponding software packages, such as KaHyPar kahypar, which has already been used in both OMEinsumContractionOrders.jl and Cotengra. ","category":"page"},{"location":"contraction_order/#Local-Search-Method","page":"Contraction Order","title":"Local Search Method","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"The local search method Kalachev (also called the tree simulated annealing) is another type of the optimization method based on local search and simulating annealing. TreeSA is based on the following rules:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Associativity: T times (S times R) = (T times S) times R,\nCommutativity: T times S = S times T.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"These rules lead to the four possible transforms of the contraction tree as shown in the following figure.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"(Image: )","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"The TreeSA method starts from a random contraction tree and then applies the above rules to transform the tree. The cost of the contraction tree is evaluated and the tree is updated according to the Metropolis criterion. During the process, the temperature is gradually decreased, and the process stop when the temperature is low enough. The method has already been used in OMEinsumContractionOrders.jl.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"The method listed above are powerful and efficient, which can be used to find great contraction orders of various tensor networks. However, the methods above except exhaustive search are heuristic methods and may not guarantee to find the optimal contraction order, while the exhaustive search can be too slow for large tensor networks. In the following sections, we will introduce a method to find the optimal contraction order based on the optimal tree decomposition.","category":"page"},{"location":"contraction_order/#Finding-the-Optimal-Contraction-Order-via-Tree-Decomposition","page":"Contraction Order","title":"Finding the Optimal Contraction Order via Tree Decomposition","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"In the previous section, we introduce the concept of tensor network and its contraction order, so that now you should understand why the contraction order so important.  Then the next question is how to find the optimal contraction order.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"In our work, we propose to use the tree decomposition of the line graph of the hypergraph representation of the tensor network to find the optimal contraction order, according to the following well known theoremMarkov :","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Theorem 1. Let C be a quantum circuit with T gates and whose underlying circuit graph is G_c. Then C can be simulated deterministically in time T^O(1) e^O(tw(G_C)), where tw(G_C) is the treewidth of G_C.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Using the language of tensor network, we can rewrite the above theorem as follows: the bottleneck of time complexity of the contraction of a tensor network is O(e^O(tw(L(G)))), where L(G) is the line graph of the hypergraph representation of the tensor network.  Therefore, if we can find the tree decomposition of the tensor network with minimal treewidth, we can find the optimal contraction order of the tensor network. We developed a package TreeWidthSolver.jl for finding the optimal tree decomposition of a given simple graph, which can be used as a backend of OMEinsumContractionOrders.jl. For more details about the tree decomposition and its relation to the contraction order, please refer to the appendix.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Here is an example of usage:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"julia> using OMEinsum, OMEinsumContractionOrders\n\n# define the contraction using Einstein summation\njulia> code = ein\"ijl, ikm, jkn, l, m, n -> \"\nijl, ikm, jkn, l, m, n -> \n\nulia> optimizer = ExactTreewidth()\nExactTreewidth{GreedyMethod{Float64, Float64}}(GreedyMethod{Float64, Float64}(0.0, 0.0, 1))\n\n# set the size of the indices\njulia> size_dict = uniformsize(code, 2)\nDict{Char, Int64} with 6 entries:\n  'n' => 2\n  'j' => 2\n  'i' => 2\n  'l' => 2\n  'k' => 2\n  'm' => 2\n\njulia> optcode = optimize_code(code, size_dict, optimizer)\nn, n -> \n├─ jk, jkn -> n\n│  ├─ ij, ik -> jk\n│  │  ├─ ijl, l -> ij\n│  │  │  ├─ ijl\n│  │  │  └─ l\n│  │  └─ ikm, m -> ik\n│  │     ├─ ikm\n│  │     └─ m\n│  └─ jkn\n└─ n\n\n# check the complexity\njulia> contraction_complexity(optcode, size_dict)\nTime complexity: 2^5.087462841250339\nSpace complexity: 2^2.0\nRead-write complexity: 2^5.882643049361841\n\n# check the results\njulia> A = rand(2, 2, 2); B = rand(2, 2, 2); C = rand(2, 2, 2); D = rand(2); E = rand(2); F = rand(2);\n\njulia> code(A, B, C, D, E, F) ≈ optcode(A, B, C, D, E, F)\ntrue","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"This optimizer will be used as an extension of TensorOperations.jl in the future, see this PR. We compared the performance of this method against the default optimizer of TensorOperations.jl based on exhaustive searching, the results is shown below.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"(Image: )","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"The results shown that the tree width based solver is faster for some graph similar to trees. For more details, please see the benchmark repo: https://github.com/ArrogantGao/TreeWidthSolver_benchmark.","category":"page"},{"location":"contraction_order/#Appendix:-Details-about-Tree-Decomposition-and-its-Relation-to-Contraction-Order","page":"Contraction Order","title":"Appendix: Details about Tree Decomposition and its Relation to Contraction Order","text":"","category":"section"},{"location":"contraction_order/#Line-Graph","page":"Contraction Order","title":"Line Graph","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"A formal definition of the line graph is as follows:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Definition 1. Given a graph G, its line graph L(G) is a graph such that: ","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"each vertex of L(G) represents an edge of G; \ntwo vertices of L(G) are adjacent if and only if their corresponding edges share a common endpoint (\"are incident\") in G. ","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"That is, it is the intersection graph of the edges of G, representing each edge by the set of its two endpoints.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"For a tensor network, we can construct a hypergraph G whose vertices are the tensors and whose hyperedges are the indices.  Then the line graph L(G) of the hypergraph G is the graph whose vertices are the indices and whose edges are the tensors, which is a simple graph, as shown in the following figure:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"(Image: Fig.1)","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Since we are considering a tensor network, dimension of the indices have to be considered.  Therefore, for each vertex of the line graph L(G), we define its weight as log_2(d), where d is the dimension of the index. In this way, size of a tensor can be represented as the sum of weights of the vertices in L(G).","category":"page"},{"location":"contraction_order/#Tree-Decomposition-and-Tree-Width","page":"Contraction Order","title":"Tree Decomposition and Tree Width","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Intuitively, a tree decomposition represents the vertices of a given graph G as subtrees of a tree, in such a way that vertices in G are adjacent only when the corresponding subtrees intersect.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"The tree decomposition of a graph is a tree whose nodes are subsets of the vertices of the graph, and the following conditions are satisfied:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Each vertex of the graph is in at least one node of the tree.\nFor each edge of the graph, there is a node of the tree containing both vertices of the edge.\nBags containing the same vertex have to be connected in the tree.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"All the nodes of the tree are called tree bags, and intersection of two bags is called a separator. The width of a tree decomposition is the size of the largest bag minus one. Clearly, one graph can have multiple tree decomposition with different corresponding widths. The tree width of a graph is the minimal width of all such decompositions, and a particular decomposition (not necessarily unique) that realises this minimal width is called an optimal tree decomposition.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"An example of the optimal tree decomposition is shown in the following figure:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"(Image: )","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"where the left graph is the original graph and the right one is the tree decomposition of the graph, and the tree width is 2.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"To find the optimal tree decomposition of a simple graph, one can use the Bouchitté-Todinca algorithm Bouchitté algorithm, one can refer to it for more details.","category":"page"},{"location":"contraction_order/#From-Tree-Decomposition-to-Contraction-Order","page":"Contraction Order","title":"From Tree Decomposition to Contraction Order","text":"","category":"section"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Then how tree decomposition and tree width are related to the contraction order of the tensor network? In this sub-section, we will answer the following questions: how to get a contraction order from a tree decomposition? And why the contraction order is optimal if the tree width is minimal?","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"For the first question, according to the definition of tree decomposition, we can obtain vertices elimination order by traversing the tree decomposition in a bottom-up manner.  For each node of the tree decomposition, a vertex can be eliminated if it is in the bag of the node and not in the bags of its parent node.  The order is i j l k m n, where the last vertex is to be eliminated first.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"The elimination order of the indices can then be used to determine the contraction order of the tensor network, where two tensors are contracted if they share a common index and the index is eliminated. According to the elimination order above, the contraction is shown below:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"(Image: )","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Of course, the contraction order is not unique as, by selecting different node as the root of the decomposition tree, different contraction orders can be obtained.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Then to answer the second question, we have to introduce a property of the optimal tree decomposition:","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Proposition 1: all tree bags of the optimal tree decomposition are cliquish, i.e., the vertices in the same bag are either connected or belong to the same separator.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"If two indices are connected in the line graph, then they at least belong to a same tensor. For the separators, notice that in a contraction order from a tree decomposition, a separator is exactly the indices of an intermediate tensor, so that they should also be treated as connected. In the example above, BE has indices ik, corresponding to the separator i k between tree bags i j k and i k m, and so on.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Therefore, in a tree bag all indices are \"connected\", in each step of the contraction, we will have to loop over all the indices in the same bag, so that the bottleneck of time complexity is exactly by O(e^tw(G) + 1), and the since all intermediate tensors are characterized by the separators, and separators are real subset of tree bags, the space complexity bounded by O(e^tw(G)).","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Remark: It should be remarked in the general cases, sizes of the separators (the intersection of the bags) may not be size of the bags minus one.","category":"page"},{"location":"contraction_order/","page":"Contraction Order","title":"Contraction Order","text":"Thus, we can conclude that the contraction order obtained from the optimal tree decomposition is the optimal contraction order of the tensor network.","category":"page"},{"location":"treewidth/#Finding-the-Optimal-Tree-Decomposition-with-Minimal-Treewidth","page":"Tree Width","title":"Finding the Optimal Tree Decomposition with Minimal Treewidth","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"This blog detailed introduce the algorithm to find the optimal tree decomposition with minimal treewidth of a given simple graph, and how it is implemented in Julia package TreeWidthSolver.jl.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"The following is the outline of this blog:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Tree width and tree decomposition\nThe Bouchitté–Todinca algorithm for exact tree width\nA Julia implementation: TreeWidthSolver.jl","category":"page"},{"location":"treewidth/#Tree-Width-and-Tree-Decomposition","page":"Tree Width","title":"Tree Width and Tree Decomposition","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"In this section, I will introduce the basic concepts of tree width and tree decomposition.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Intuitively, a tree decomposition represents the vertices of a given graph G as subtrees of a tree, in such a way that vertices in G are adjacent only when the corresponding subtrees intersect.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Defination 1 (tree decomposition): The tree decomposition of a graph is a tree whose nodes are subsets of the vertices of the graph, and the following conditions are satisfied:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Each vertex of the graph is in at least one node of the tree.\nFor each edge of the graph, there is a node of the tree containing both vertices of the edge.\nBags containing the same vertex have to be connected in the tree.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"An example of tree decomposition is shown in the following figure:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"(Image: )","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"where the (b) is the original graph and the (c) is the tree decomposition of the graph.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"The nodes of the tree are called tree bags. The width of a tree decomposition is the size of the largest bag minus one, thus the width of the example above is 2. Clearly, one graph can have multiple tree decompositions, and the tree width of a graph is the minimum width of all possible tree decompositions.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Tree decompositions play an important role in graph theory and combinatorial optimization, many NP-hard problems such as maximum independent set, minimum dominating set, chromatic number, and Hamiltonicity can be solved with dynamic programming over a tree decomposition, with a running time exponential in the width of the decomposition but linear in the size of the graph For our purpose, tree decompositions can be used to optimize the contraction order of tensor networks, which is a key step in many quantum many-body simulations. However, find the optimal tree decomposition with minimal treewidth is also an NP-hard problem. In the following sections, I will introduce an exact algorithm to calculate the treewidth of a graph.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Another important concept is the vertex elimination order, which can be obtained from the tree decomposition. An example is shown below, where the tree decomposition of the graph above is formulated as a tree by selecting one of the tree bag as root. Then a vertex is eliminated if it exists in child bags but not in the parent bag, and the elimination order is the order of the vertices being eliminated, and child of the same parent can be eliminated in arbitrary order. In this example, the elimination order is A B C D G F H, where the last is the first to be eliminated.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"(Image: )","category":"page"},{"location":"treewidth/#The-Bouchitté–Todinca-Algorithm-for-Exact-Tree-Width","page":"Tree Width","title":"The Bouchitté–Todinca Algorithm for Exact Tree Width","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Various algorithms have been developed to calculate the treewidth of a graph in the past few decades, both exactly and approximately. In this section, I will introduce one of the most basic exact algorithms: the Bouchitté–Todinca (BT) algorithm Bouchitte BouchitteListing Tuukka, which makes use of the theory of minimal triangulations, characterizing the minimal triangulations of a graph via objects called minimal separators and potential maximal cliques of the graph.","category":"page"},{"location":"treewidth/#Triangulation-and-Minimal-Triangulation","page":"Tree Width","title":"Triangulation and Minimal Triangulation","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"First of all, let's introduce the concept of triangulation and minimal triangulation.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Triangulations of graphs are a central graph-theoretic concept in the computation of tree decompositions.  Triangulations are defined via chordality of graphs.  A graph G is chordal if every cycle in G with at least 4 vertices contains a chord, which is an edge that is not part of the cycle but connects two vertices of the cycle Correspondingly, a non-chordal graph has at least one chordless cycle, i.e., a cycle with at least 4 vertices that does not have a chord.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Definition 2 (triangulation). A graph H is a triangulation of a graph G if H is chordal, V (G) = V (H), and E(G) subseteq E(H).","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Here is an example of a triangulation of a graph:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"(Image: )","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"where the left graph is the original graph and the right one is a triangulation of the graph.","category":"page"},{"location":"treewidth/#Minimal-Separator-and-Potential-Maximal-Cliques","page":"Tree Width","title":"Minimal Separator and Potential Maximal Cliques","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Then we can introduce the concept of minimal separator and potential maximal cliques.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"A set of vertices S subseteq V (G) is an ab-separator of a graph G if the vertices a and b are in different connected components of G setminus S.  In other words, all paths between a and b go through S. The set S is a minimal ab-separator of G if no subset of S is also an ab-separator. The minimal separator of a graph is defined as follows:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Defination 3 (minimal separator): Let G be a graph. A set of vertices S subseteq V (G) is a minimal separator of G if it is a minimal ab-separator for some pair a b in V (G).","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"For example, in the graph shown above, the set B C is a minimal separator of the graph, which separates the graph into two disconnected parts: A and D E F G H. It is also easy to see that the set BC is exactly the intersection of the two neighboring bags A B C and B C E in the tree decomposition. Actually, all intersection of neighboring bags in a tree decomposition is a separator of the graph.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"(Image: )","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Defination 4 (potential maximal clique): A set of vertices Omega subseteq V (G) is a potential maximal clique of a graph G if there is a minimal triangulation H of G such that Omega is a maximal clique of H. A set of vertices is a maximal clique if it is a clique and no strict superset of it is a clique.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"For example, in the graph shown above, the sets BCE, BGE, BCG and C E G are all potential maximal cliques of the graph, corresponding to different triangulations of the graph:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"(Image: )","category":"page"},{"location":"treewidth/#The-Bouchitté–Todinca-Dynamic-Programming-Algorithm","page":"Tree Width","title":"The Bouchitté–Todinca Dynamic Programming Algorithm","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"The reason that we are interested in minimal separators and potential maximal cliques the following properties of the optimal tree decomposition:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"All tree bags of a tree decomposition with minimal treewidth are potential maximal cliques of the graph.\nThe intersection of any two neighboring bags in a tree decomposition is a minimal separator of the graph.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Based on these properties, the Bouchitté–Todinca algorithm first calculates all minimal separators and potential maximal cliques of the graph, and then uses dynamic programming to find a set of potential maximal cliques that minimizes the width of the tree decomposition.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"In this section, I will introduce the Bouchitté–Todinca algorithm in detail, which can be separated into the following steps:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"List all minimal separators, Delta;\nList all potential maximal cliques, Pi;\nCalculate the treewidth of the graph.","category":"page"},{"location":"treewidth/#Step-1:-List-all-minimal-separators","page":"Tree Width","title":"Step 1: List all minimal separators","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"To recognize minimal separators of a graph, we mainly use the following property.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"For a set of vertices S, consider the connected components of G setminus S, represented as mathcalC(G setminus S), which are called the components of S. For C in mathcalC(G setminus S), if N(C) = S, then C is called a full-component of S.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Theorem 1 (minimal separator): The set S is a minimal separator if and only if it has two or more than two full-components.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"For example, B C is a minimal separator of the graph shown above, with two full-components A and D E F G H. While B C F is not, since it has only one full-component D E G H.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"It is shown that the following proposition holds:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Proposition 1: Let S be a minimal separator of a graph G and a a vertex of G, then neighbors of the connected components of G setminus (S cup a), i.e. $ \\mathcal{R}(S) = {N(C) | C \\in \\mathcal{C}(G \\setminus (S \\cup {a}))} $ are all minimal separators of the graph.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Then we start from all vertices v of the graph and theirs neighbor N(v), and repeatedly apply the proposition above to list all minimal separators of the graph.","category":"page"},{"location":"treewidth/#Step-2:-List-all-potential-maximal-cliques","page":"Tree Width","title":"Step 2: List all potential maximal cliques","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"In the second step we list all potential maximal cliques of the graph using Delta calculated in the first step. To check a set of vertices Omega is a potential maximal clique, we can use the following property:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Theorem 2 (potential maximal clique): Let Omega be a set of vertices of a graph G. The set Omega is a potential maximal clique if and only if the following conditions hold:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"for any pair of vertices a b in Omega, either a and b are connected by an edge in the graph, or there is a minimal separator S such that a in S and b in S;\nno component of Omega is full;","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"where the first one is called the cliquish condition, and the second one is called the non-full condition.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Then, one can use the following rules to list all potential maximal cliques: ","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Proposition 2: Let Omega be a potential maximal clique and a a vertex of G, and a is a vertex of G. If V(G) geq 2, one of the following conditions holds:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Omega setminus a in Pi(G setminus a)\n;\nOmega setminus a in Delta(G)\n;\nOmega = S cup T setminus a\n, where S and T are minimal separators of G such that a notin S, S notin Delta(G setminus a) and a in T.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"The proposition indicates that with Pi(G setminus a), Delta(G setminus a) and Delta(G), one can construct Pi(G) by adding one vertex a to the graph.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Then one can iteratively construct the graph by adding one vertex each time, here we represent the i-th graph as G_i = G(v_1 v_2 cdots v_i), and then calculate Pi(G_i) using Pi(G_i-1), Delta(G_i-1) and Delta(G_i) according to the proposition above, until i = N and all potential maximal cliques are found.","category":"page"},{"location":"treewidth/#Step-3:-Calculate-the-treewidth-of-the-graph","page":"Tree Width","title":"Step 3: Calculate the treewidth of the graph","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Finally, we can calculate the treewidth of the graph using Delta and Pi calculated in the first two steps.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"The BT algorithm is based on the following two ideas: ","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"all tree bags of the tree decomposition with minimal treewidth are potential maximal cliques of the graph;\ntree width of a graph is larger than that of its subgraphs.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Then for a given potential maximal clique Omega, the minimal treewidth among all tree decompositions with Omega is given by tw(Omega) = max(Omega - 1 tw(G(C_i cup S_i)))C_i in mathcalC(G setminus Omega)S_i = C_i cap Omega and the treewidth of the graph is the minimum of tw(Omega) among all potential maximal cliques Omega.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"For example, in the figure below, we assume that the potential maximal clique Omega = B C E with width 2 is in the decomposition, and then we need to compare that against the width of the subgraphs G(A B C), G(C D E) and G(B E F G H). Since A B C and C D E are already potential maximal cliques, theirs width is 2; and for G(B E F G H), we can apply a similar procedure to calculate the width of the subgraphs, which is also 2. Thus tw(B C E) = 2. By comparing width of all possible choices of Omega, we can find the treewidth of the graph.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"The BT algorithm first calculates all possible G(C cup S) for all Omega and sort the triplets (Omega C S) according to size of C cup S. Then with the help of dynamic programming, the algorithm calculate width of subgraph G(C cup S) from the smallest to the largest. In each step, treewidth of all possible subgraphs of the current graph G(C cup S) is already calculated, so that the treewidth of G(C cup S) can be directly obtain by comparing the width of the subgraphs and Omega - 1.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Furthermore, if the choice of Omega of each step is stored, the tree decomposition can be easily obtained by connecting these potential maximal cliques.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Using the BT algorithm, one can calculate the treewidth of a graph exactly, and the algorithm has a time complexity of O(Pinm), which are dependent on the graph structure.","category":"page"},{"location":"treewidth/#A-Julia-Implementation:-TreeWidthSolver.jl","page":"Tree Width","title":"A Julia Implementation: TreeWidthSolver.jl","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"In this section, I will introduce how the algorithm is implemented in the package TreeWidthSolver.jl, which is a simple and efficient implementation of the Bouchitté–Todinca algorithm for exact tree width calculation. The package in developed using the Julia Programming Language, which is a high performance programming language develop in the past decade. For readers who are not familiar with Julia, I recommend this article: Effective Extensible Programming: Unleashing Julia on GPUs, which gives a brief introduction to the language and its features.","category":"page"},{"location":"treewidth/#Highly-Efficient-Set-Operations-with-BitBasis.jl","page":"Tree Width","title":"Highly Efficient Set Operations with BitBasis.jl","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"In the BT algorithm, the main operations are finding connected components of induced subgraphs, and finding neighbors of a set of vertices. However, in the Julia package Graphs.jl, the vertices are stored as integers, as shown below:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"julia> using Graphs\n\njulia> g = smallgraph(:petersen)\n{10, 15} undirected simple Int64 graph\n\njulia> g.fadjlist\n10-element Vector{Vector{Int64}}:\n [2, 5, 6]\n [1, 3, 7]\n [2, 4, 8]\n [3, 5, 9]\n [1, 4, 10]\n [1, 8, 9]\n [2, 9, 10]\n [3, 6, 10]\n [4, 6, 7]\n [5, 7, 8]","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"If we use a similar data structure and use Vector or Set of integers to represent the vertices set, these operations are easy to implement but will be very slow, due to the slow set operations and huge memory usage.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"To reach a highly efficient implementation, we use the bit array to represent the sets of vertices, based on the LongLongUInt type provided in the package BitBasis.jl, which provides types and operations for basis represented by bits in linear algebra.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"For example, here we show how to use generate a bit array to represent the set of vertices 1 2  10 of a graph:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"julia> using BitBasis\n\njulia> a = bmask(LongLongUInt{1}, 1:10)\nLongLongUInt{1}((0x00000000000003ff,))\n\njulia> typeof(a)\nLongLongUInt{1}\n\njulia> isbitstype(typeof(a))\ntrue\n\n# vizualize the bit array, not necessary\njulia> BitStr{64}(a)\n0000000000000000000000000000000000000000000000000000001111111111 ₍₂₎","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"and of course the set operations are also supported:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"julia> a = bmask(LongLongUInt{1}, 1:10)\nLongLongUInt{1}((0x00000000000003ff,))\n\njulia> b = bmask(LongLongUInt{1}, 8:12)\nLongLongUInt{1}((0x0000000000000f80,))\n\n# for simplicity, we only show the first 15 bits\njulia> BitStr{15}(a)\n000001111111111 ₍₂₎\n\njulia> BitStr{15}(b)\n000111110000000 ₍₂₎\n\n# a ∪ b\njulia> BitStr{15}(a | b)\n000111111111111 ₍₂₎\n\n# a ∩ b\njulia> BitStr{15}(a & b)\n000001110000000 ₍₂₎","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Since they are all bitwise operations, the operations are very fast and memory efficient.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"julia> set_a = Set([1:10...]);\n\njulia> set_b = Set([8:12...]);\n\njulia> @benchmark $set_a ∩ $set_b\nBenchmarkTools.Trial: 10000 samples with 952 evaluations.\n Range (min … max):   93.269 ns …  52.749 μs  ┊ GC (min … max):  0.00% … 99.77%\n Time  (median):      95.982 ns               ┊ GC (median):     0.00%\n Time  (mean ± σ):   111.883 ns ± 533.091 ns  ┊ GC (mean ± σ):  10.14% ±  7.71%\n\n  █▇▄▄▃▃▂▂▂▂▁▁                                                  ▂\n  █████████████▇▇▆▅▅▄▃▁▁▁▄▁▁▃▁▃▁▄▃▁▃▃▃▁▄▁▃▃▄▄▁▁▁▁▁▁▁▃▁▄▁▃▁▁▁▁▁▃ █\n  93.3 ns       Histogram: log(frequency) by time        262 ns <\n\n Memory estimate: 400 bytes, allocs estimate: 4.\n\njulia> @benchmark $a & $b\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  1.416 ns … 3.666 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     1.500 ns             ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.486 ns ± 0.036 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n                    ▁                  █\n  ▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▅▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃ ▂\n  1.42 ns        Histogram: frequency by time       1.54 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n\njulia> @benchmark $set_a ∪ $set_b\nBenchmarkTools.Trial: 10000 samples with 585 evaluations.\n Range (min … max):  208.405 ns …  85.538 μs  ┊ GC (min … max): 0.00% … 99.69%\n Time  (median):     211.538 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   237.770 ns ± 863.046 ns  ┊ GC (mean ± σ):  9.13% ±  8.69%\n\n  █▄▃                                                           ▁\n  ███▇▅▄▅▃▃▃▃▁▃▃▁▁▁▁▁▁▁▁▃▃▁▃▁▁▁▁▃▁▁▁▁▁▁▃▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▄▄ █\n  208 ns        Histogram: log(frequency) by time       1.31 μs <\n\n Memory estimate: 880 bytes, allocs estimate: 7.\n\njulia> @benchmark $a | $b\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  1.416 ns … 8.500 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     1.500 ns             ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.542 ns ± 0.134 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n     ▆  █   ▇  ▆  ▃   ▁  ▁                          ▂       ▂\n  ▇▁▁█▁▁█▁▁▁█▁▁█▁▁█▁▁▁█▁▁█▁▁▇▁▁▁▇▁▁▇▁▁▅▁▁▁▅▁▁█▁▁▇▁▁▁█▁▁▇▁▁▇ █\n  1.42 ns     Histogram: log(frequency) by time     2.12 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Based on that, we used a self-defined data structure MaskedBitGraph to store the graph, where contains the following information:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"a bit array mask to represent the active vertices of the graph, so that when considering a subgraph, we can simply change the mask instead of creating a new graph;\nfor each vertex, both the adjacency list and the bit array representing its neighbors are stored, so that we can easily find the neighbors of a set of vertices and operate on the bit array.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"julia> using TreeWidthSolver, Graphs\n\njulia> g = smallgraph(:petersen)\n{10, 15} undirected simple Int64 graph\n\njulia> bit_g = MaskedBitGraph(g)\nMaskedBitGraph{LongLongUInt{1}}, N: 10, nv: 10, mask: 1111111111 ₍₂₎\n\njulia> bit_g.mask\n0000000000000000000000000000000000000000000000000000001111111111 ₍₂₎\n\njulia> bit_g.fadjlist\n10-element Vector{Vector{Int64}}:\n [2, 5, 6]\n [1, 3, 7]\n [2, 4, 8]\n [3, 5, 9]\n [1, 4, 10]\n [1, 8, 9]\n [2, 9, 10]\n [3, 6, 10]\n [4, 6, 7]\n [5, 7, 8]\n\njulia> bit_g.bitgraph\n10-element Vector{LongLongUInt{1}}:\n 0000000000000000000000000000000000000000000000000000000000110010 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000001000101 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000010001010 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000100010100 ₍₂₎\n 0000000000000000000000000000000000000000000000000000001000001001 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000110000001 ₍₂₎\n 0000000000000000000000000000000000000000000000000000001100000010 ₍₂₎\n 0000000000000000000000000000000000000000000000000000001000100100 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000001101000 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000011010000 ₍₂₎","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Based on that, we can achieve high performance graph operations, including finding neighbors of a set of vertices, finding connected components of a subgraph.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"julia> g = random_regular_graph(100, 3)\n{100, 150} undirected simple Int64 graph\n\njulia> @benchmark connected_components($g)\nBenchmarkTools.Trial: 10000 samples with 9 evaluations.\n Range (min … max):  2.227 μs …  8.521 ms  ┊ GC (min … max):  0.00% … 99.93%\n Time  (median):     2.495 μs              ┊ GC (median):     0.00%\n Time  (mean ± σ):   3.530 μs ± 85.207 μs  ┊ GC (mean ± σ):  24.48% ±  1.86%\n\n  █▆ ▂▂\n  ██████▇▆▄▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▁▁▁▂▂▁▁▂▂▂▂▁▂▂▁▂▂▂▂▂▂▂▂▂▂▂ ▃\n  2.23 μs        Histogram: frequency by time         6.7 μs <\n\n Memory estimate: 5.38 KiB, allocs estimate: 15.\n\njulia> bit_g = MaskedBitGraph(g)\nMaskedBitGraph{LongLongUInt{2}}, N: 100, nv: 100, mask: 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 ₍₂₎\n\njulia> @benchmark TreeWidthSolver.bit_connected_components($bit_g)\nBenchmarkTools.Trial: 10000 samples with 10 evaluations.\n Range (min … max):  991.600 ns …   6.825 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):       1.004 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):     1.038 μs ± 145.816 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▄█▆▃▃▃▂▂▂▃▃▄▃▁▂▁                                              ▂\n  ████████████████▇██▇▆▇▇▅▆▅▅▄▅▅▄▅▅▄▅▅▅▅▄▅▁▅▄▆▅▅▅▄▇▆▅▆▆▇▆▇▇▆▇▇▆ █\n  992 ns        Histogram: log(frequency) by time       1.42 μs <\n\n Memory estimate: 208 bytes, allocs estimate: 2.","category":"page"},{"location":"treewidth/#User-Interface-and-Examples","page":"Tree Width","title":"User Interface and Examples","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"The user interface of this package is quite simple, three functions are provided:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"exact_treewidth(g::SimpleGraph{TG}; weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TW}: Compute the exact treewidth of a given graph g using the BT algorithm.\ndecomposition_tree(g::SimpleGraph{TG}; labels::Vector{TL} = collect(1:nv(g)), weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TW, TL}: Compute the tree decomposition with minimal treewidth of a given graph g using the BT algorithm.\nelimination_order(g::SimpleGraph{TG}; labels::Vector{TL} = collect(1:nv(g)), weights::Vector{TW} = ones(nv(g)), verbose::Bool = false) where {TG, TL, TW}: Compute the elimination order of a given graph g using the BT algorithm.","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"Here are some examples:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"julia> using TreeWidthSolver, Graphs\n\njulia> g = smallgraph(:petersen)\n{10, 15} undirected simple Int64 graph\n\n# calculate the exact treewidth of the graph\njulia> exact_treewidth(g)\n4.0\n\n# show more information\njulia> exact_treewidth(g, verbose = true)\n[ Info: computing all minimal separators\n[ Info: allminseps: 10, 15\n[ Info: all minimal separators computed, total: 15\n[ Info: computing all potential maximal cliques\n[ Info: vertices: 9, Δ: 15, Π: 0\n[ Info: vertices: 8, Δ: 14, Π: 9\n[ Info: vertices: 7, Δ: 13, Π: 16\n[ Info: vertices: 6, Δ: 9, Π: 24\n[ Info: vertices: 5, Δ: 6, Π: 35\n[ Info: vertices: 4, Δ: 5, Π: 36\n[ Info: vertices: 3, Δ: 2, Π: 43\n[ Info: vertices: 2, Δ: 1, Π: 44\n[ Info: vertices: 1, Δ: 1, Π: 44\n[ Info: computing all potential maximal cliques done, total: 45\n[ Info: computing the exact treewidth using the Bouchitté-Todinca algorithm\n[ Info: precomputation phase\n[ Info: precomputation phase completed, total: 135\n[ Info: computing the exact treewidth done, treewidth: 4.0\n4.0\n\n# construct the tree decomposition\njulia> decomposition_tree(g)\ntree width: 4.0\ntree decomposition:\nSet([5, 6, 7, 3, 1])\n├─ Set([7, 2, 3, 1])\n├─ Set([5, 4, 6, 7, 3])\n│  └─ Set([4, 6, 7, 9])\n└─ Set([5, 6, 7, 10, 3])\n   └─ Set([6, 10, 8, 3])\n\n# similar for the elimination order\njulia> elimination_order(g)\n6-element Vector{Vector{Int64}}:\n [1, 3, 7, 6, 5]\n [10]\n [8]\n [4]\n [9]\n [2]\n\n# one can also assign labels to the vertices\njulia> elimination_order(g, labels = ['a':'j'...])\n6-element Vector{Vector{Char}}:\n ['a', 'c', 'g', 'f', 'e']\n ['j']\n ['h']\n ['d']\n ['i']\n ['b']","category":"page"},{"location":"treewidth/#Performance-Benchmark","page":"Tree Width","title":"Performance Benchmark","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"We benchmarked the package on a set of random graphs with different sizes, including the 3-regular graph, line graph and random tree graph, and the results are shown below:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"(Image: )","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"where n is the number of vertices of the graph, T is the time used to calculate the treewidth of the graph. Results for the 3-regular graph and random tree graph are averaged over 10 samples. The results show that for different types of graphs, the time used to calculate the treewidth can be quite different, and the time complexity of the algorithm is dependent on the graph structure. For simple line/tree graphs, the BT algorithm can reach a polynomial time complexity and calculate the treewidth of the graph in a short time, while for more complex graphs, the time used can be much longer. It has been proved that the upper bound of this algorithm is about O(17^n).","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"For more details about the benchmark, please see this repo: https://github.com/ArrogantGao/TreeWidthSolver_benchmark.","category":"page"},{"location":"treewidth/#Future-Work","page":"Tree Width","title":"Future Work","text":"","category":"section"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"This package is still under development, and there are several aspects that can be improved:","category":"page"},{"location":"treewidth/","page":"Tree Width","title":"Tree Width","text":"the speed of the current package is still outperformed by the C++ implementation Triangulator, and we are working on improving the performance of the package;\nmore algorithm can be implemented in the package, for example the Tamaki's algorithm for tree width.","category":"page"},{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Pages = [\"ref.md\"]","category":"page"},{"location":"ref/#OMEinsumContractionOrders.ExactTreewidth","page":"Reference","title":"OMEinsumContractionOrders.ExactTreewidth","text":"const ExactTreewidth{GM} = Treewidth{SafeRules{BT, MMW{3}(), MF}, GM}\nExactTreewidth(; greedy_config = GreedyMethod(nrepeat=1)) = Treewidth(; greedy_config)\n\nExactTreewidth is a specialization of Treewidth for the SafeRules preprocessing algorithm with the BT elimination algorithm. The BT algorithm is an exact solver for the treewidth problem that implemented in TreeWidthSolver.jl.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.GreedyMethod","page":"Reference","title":"OMEinsumContractionOrders.GreedyMethod","text":"GreedyMethod{MT}\nGreedyMethod(; α = 0.0, temperature = 0.0, nrepeat=1)\n\nThe fast but poor greedy optimizer. Input arguments are\n\n* `α` is the parameter for the loss function, for pairwise interaction, L = size(out) - α * (size(in1) + size(in2))\n* `temperature` is the parameter for sampling, if it is zero, the minimum loss is selected; for non-zero, the loss is selected by the Boltzmann distribution, given by p ~ exp(-loss/temperature).\n* `nrepeat` is the number of repeatition, returns the best contraction order.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.HyperND","page":"Reference","title":"OMEinsumContractionOrders.HyperND","text":"HyperND(;\n    dis = KaHyParND(),\n    algs = (MF(), MMD()),\n    level = 6,\n    width = 120,\n    imbalances = 130:130,\n)\n\nNested-dissection based optimizer. Recursively partitions a tensor network, then calls a greedy algorithm on the leaves. The optimizer is run a number of times: once for each greedy algorithm in algs and each imbalance value in imbalances. The recursion depth is controlled by the parameters level and width.\n\nThe line graph is partitioned using the algorithm dis. OMEinsumContractionOrders currently supports two partitioning algorithms, both of which require importing an external library.\n\ntype package\nMETISND Metis.jl\nKaHyParND KayHyPar.jl\n\nThe optimizer is implemented using the tree decomposition library CliqueTrees.jl.\n\nArguments\n\ndis: graph partitioning algorithm\nalgs: tuple of elimination algorithms.\nlevel: maximum level\nwidth: minimum width\nimbalances: imbalance parameters \n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.KaHyParBipartite","page":"Reference","title":"OMEinsumContractionOrders.KaHyParBipartite","text":"KaHyParBipartite{RT,IT,GM}\nKaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),\n    max_group_size=40, greedy_config=GreedyMethod())\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nimbalances is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,\nmax_group_size is the maximum size that allowed to used greedy search,\ngreedy_config is a greedy optimizer.\n\nReferences\n\nHyper-optimized tensor network contraction\nSimulating the Sycamore quantum supremacy circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeGreedy","page":"Reference","title":"OMEinsumContractionOrders.MergeGreedy","text":"MergeGreedy <: CodeSimplifier\nMergeGreedy(; threshhold=-1e-12)\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges tensors greedily if the space complexity of merged tensors is reduced (difference smaller than the threshhold).\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeVectors","page":"Reference","title":"OMEinsumContractionOrders.MergeVectors","text":"MergeVectors <: CodeSimplifier\nMergeVectors()\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges vectors to closest tensors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.SABipartite","page":"Reference","title":"OMEinsumContractionOrders.SABipartite","text":"SABipartite{RT,BT}\nSABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000\n    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsize_dict, a dictionary that specifies leg dimensions,\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nmax_group_size is the maximum size that allowed to used greedy search,\nβs is a list of inverse temperature 1/T,\nniters is the number of iteration in each temperature,\nntrials is the number of repetition (with different random seeds),\nsub_optimizer, the optimizer for the bipartited sub graphs, one can choose GreedyMethod() or TreeSA(),\ninitializer, the partition configuration initializer, one can choose :random or :greedy (slow but better).\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.TreeSA","page":"Reference","title":"OMEinsumContractionOrders.TreeSA","text":"TreeSA{RT,IT,GM}\nTreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,\n    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))\n\nOptimize the einsum contraction pattern using the simulated annealing on tensor expression tree.\n\nsc_target is the target space complexity,\nntrials, βs and niters are annealing parameters, doing ntrials indepedent annealings, each has inverse tempteratures specified by βs, in each temperature, do niters updates of the tree.\nsc_weight is the relative importance factor of space complexity in the loss compared with the time complexity.\nrw_weight is the relative importance factor of memory read and write in the loss compared with the time complexity.\ninitializer specifies how to determine the initial configuration, it can be :greedy or :random. If it is using :greedy method to generate the initial configuration, it also uses two extra arguments greedy_method and greedy_nrepeat.\nnslices is the number of sliced legs, default is 0.\nfixed_slices is a vector of sliced legs, default is [].\n\nReferences\n\nRecursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.Treewidth","page":"Reference","title":"OMEinsumContractionOrders.Treewidth","text":"struct Treewidth{EL <: EliminationAlgorithm, GM} <: CodeOptimizer\nTreewidth(; alg::EL = SafeRules(BT(), MMW{3}(), MF()), greedy_config::GM = GreedyMethod(nrepeat=1))\n\nTree width based solver. The solvers are implemented in CliqueTrees.jl and TreeWidthSolver.jl. They include:\n\nAlgorithm Description Time Complexity Space Complexity\nBFS breadth-first search O(m + n) O(n)\nMCS maximum cardinality search O(m + n) O(n)\nLexBFS lexicographic breadth-first search O(m + n) O(m + n)\nRCMMD reverse Cuthill-Mckee (minimum degree) O(m + n) O(m + n)\nRCMGL reverse Cuthill-Mckee (George-Liu) O(m + n) O(m + n)\nMCSM maximum cardinality search (minimal) O(mn) O(n)\nLexM lexicographic breadth-first search (minimal) O(mn) O(n)\nAMF approximate minimum fill O(mn) O(m + n)\nMF minimum fill O(mn²) -\nMMD multiple minimum degree O(mn²) O(m + n)\n\nDetailed descriptions is available in the CliqueTrees.jl.\n\nFields\n\nalg::EL: The algorithm to use for the treewidth calculation. Available elimination algorithms are listed above.\ngreedy_config::GM: The configuration for the greedy method.\n\nExample\n\njulia> optimizer = Treewidth();\n\njulia> eincode = OMEinsumContractionOrders.EinCode([['a', 'b'], ['a', 'c', 'd'], ['b', 'c', 'e', 'f'], ['e'], ['d', 'f']], ['a'])\nab, acd, bcef, e, df -> a\n\njulia> size_dict = Dict([c=>(1<<i) for (i,c) in enumerate(['a', 'b', 'c', 'd', 'e', 'f'])]...)\nDict{Char, Int64} with 6 entries:\n  'f' => 64\n  'a' => 2\n  'c' => 8\n  'd' => 16\n  'e' => 32\n  'b' => 4\n\njulia> optcode = optimize_code(eincode, size_dict, optimizer)\nab, ab -> a\n├─ fac, bcf -> ab\n│  ├─ df, acd -> fac\n│  │  ├─ df\n│  │  └─ acd\n│  └─ e, bcef -> bcf\n│     ├─ e\n│     └─ bcef\n└─ ab\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.contraction_complexity-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}","page":"Reference","title":"OMEinsumContractionOrders.contraction_complexity","text":"contraction_complexity(eincode, size_dict) -> ContractionComplexity\n\nReturns the time, space and read-write complexity of the einsum contraction. The returned object contains 3 fields:\n\ntime complexity tc defined as log2(number of element-wise multiplications).\nspace complexity sc defined as log2(size of the maximum intermediate tensor).\nread-write complexity rwc defined as log2(the number of read-write operations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.flop-Union{Tuple{VT}, Tuple{LT}, Tuple{OMEinsumContractionOrders.EinCode, Dict{LT, VT}}} where {LT, VT}","page":"Reference","title":"OMEinsumContractionOrders.flop","text":"flop(eincode, size_dict) -> Int\n\nReturns the number of iterations, which is different with the true floating point operations (FLOP) by a factor of 2.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.label_elimination_order-Tuple{OMEinsumContractionOrders.NestedEinsum}","page":"Reference","title":"OMEinsumContractionOrders.label_elimination_order","text":"label_elimination_order(code) -> Vector\n\nReturns a vector of labels sorted by the order they are eliminated in the contraction tree. The contraction tree is specified by code, which e.g. can be a NestedEinsum instance.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_code","page":"Reference","title":"OMEinsumContractionOrders.optimize_code","text":"optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing, permute=true) -> optimized_eincode\n\nOptimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a NestedEinsum instance. Input arguments are\n\neincode is an einsum contraction code instance, one of DynamicEinCode, StaticEinCode or NestedEinsum.\nsize is a dictionary of \"edge label=>edge size\" that contains the size information, one can use uniformsize(eincode, 2) to create a uniform size.\noptimizer is a CodeOptimizer instance, should be one of GreedyMethod, Treewidth, KaHyParBipartite, SABipartite or TreeSA. Check their docstrings for details.\nsimplifier is one of MergeVectors or MergeGreedy.\noptimize the permutation if permute is true.\n\nExamples\n\njulia> using OMEinsum\n\njulia> code = ein\"ij, jk, kl, il->\"\nij, jk, kl, il -> \n\njulia> optimize_code(code, uniformsize(code, 2), TreeSA());\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsumContractionOrders.optimize_greedy-Union{Tuple{T2}, Tuple{TT}, Tuple{TA}, Tuple{L}, Tuple{OMEinsumContractionOrders.EinCode{L}, Dict{L, T2}}} where {L, TA, TT, T2}","page":"Reference","title":"OMEinsumContractionOrders.optimize_greedy","text":"optimize_greedy(eincode, size_dict; α = 0.0, temperature = 0.0, nrepeat=1)\n\nGreedy optimizing the contraction order and return a NestedEinsum object. Check the docstring of tree_greedy for detailed explaination of other input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_kahypar-Tuple{OMEinsumContractionOrders.EinCode, Any}","page":"Reference","title":"OMEinsumContractionOrders.optimize_kahypar","text":"optimize_kahypar(code, size_dict; sc_target, max_group_size=40, imbalances=0.0:0.01:0.2, greedy_method=MinSpaceOut(), greedy_nrepeat=1)\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. size_dict is a dictionary that specifies leg dimensions.  Check the docstring of KaHyParBipartite for detailed explaination of other input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_kahypar_auto-Tuple{OMEinsumContractionOrders.EinCode, Any}","page":"Reference","title":"OMEinsumContractionOrders.optimize_kahypar_auto","text":"optimize_kahypar_auto(code, size_dict; max_group_size=40, sub_optimizer = GreedyMethod())\n\nFind the optimal contraction order automatically by determining the sc_target with bisection. It can fail if the tree width of your graph is larger than 100.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_sa-Tuple{OMEinsumContractionOrders.EinCode, Any}","page":"Reference","title":"OMEinsumContractionOrders.optimize_sa","text":"optimize_sa(code, size_dict; sc_target, max_group_size=40, βs=0.1:0.2:15.0, niters=1000, ntrials=50,\n       sub_optimizer = GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. size_dict is a dictionary that specifies leg dimensions.  Check the docstring of SABipartite for detailed explaination of other input arguments.\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_tree-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}","page":"Reference","title":"OMEinsumContractionOrders.optimize_tree","text":"optimize_tree(code, size_dict; sc_target=20, βs=0.1:0.1:10, ntrials=2, niters=100, sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_method=MinSpaceOut(), fixed_slices=[])\n\nOptimize the einsum contraction pattern specified by code, and edge sizes specified by size_dict. Check the docstring of TreeSA for detailed explaination of other input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_treewidth-Union{Tuple{EL}, Tuple{GM}, Tuple{Treewidth{EL, GM}, OMEinsumContractionOrders.AbstractEinsum, Dict}} where {GM, EL}","page":"Reference","title":"OMEinsumContractionOrders.optimize_treewidth","text":"optimize_treewidth(optimizer, eincode, size_dict)\n\nOptimizing the contraction order via solve the exact tree width of the line graph corresponding to the eincode and return a NestedEinsum object. Check the docstring of treewidth_method for detailed explaination of other input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.peak_memory-Tuple{OMEinsumContractionOrders.NestedEinsum, Dict}","page":"Reference","title":"OMEinsumContractionOrders.peak_memory","text":"peak_memory(code, size_dict::Dict) -> Int\n\nEstimate peak memory in number of elements.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.tree_greedy-Union{Tuple{ET}, Tuple{TT}, Tuple{TA}, Tuple{OMEinsumContractionOrders.IncidenceList{Int64, ET}, Any}} where {TA, TT, ET}","page":"Reference","title":"OMEinsumContractionOrders.tree_greedy","text":"tree_greedy(incidence_list, log2_sizes; α = 0.0, temperature = 0.0, nrepeat=1)\n\nCompute greedy order, and the time and space complexities, the rows of the incidence_list are vertices and columns are edges. log2_sizes are defined on edges. α is the parameter for the loss function, for pairwise interaction, L = size(out) - α * (size(in1) + size(in2)) temperature is the parameter for sampling, if it is zero, the minimum loss is selected; for non-zero, the loss is selected by the Boltzmann distribution, given by p ~ exp(-loss/temperature).\n\n\n\n\n\n","category":"method"},{"location":"#OMEinsumContractionOrders","page":"Home","title":"OMEinsumContractionOrders","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for OMEinsumContractionOrders, a Julia package for the optimization of the contraction order of tensor networks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installation guide is available in README.md. You can also access its features in OMEinsum, which uses it as the default contraction order optimizer.","category":"page"},{"location":"#Example-1:-Use-it-directly","page":"Home","title":"Example 1: Use it directly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The contraction order optimizer is implemented in the optimize_code function. It takes three arguments: code, size, and optimizer. The code argument is the einsum notation to be optimized. The size argument is the size of the variables in the einsum notation. The optimizer argument is the optimizer to be used. The optimize_code function returns the optimized contraction order. One can use contraction_complexity function to get the time, space and rewrite complexity of returned contraction order. Supported solvers include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optimizer Description\nGreedyMethod Fast, but poor resulting order\nTreeSA Reliable, local search based optimizer [Kalachev2021], but is a bit slow\nKaHyParBipartite and SABipartite Graph bipartition based, suited for large tensor networks [Gray2021], requires using KaHyPar package\nTreewidth Tree width solver based, based on package CliqueTrees, performance is elimination algorithm dependent\nExactTreewidth (alias of Treewidth{RuleReduction{BT}}) Exact, but takes exponential time [Bouchitté2001], based on package TreeWidthSolver\nHyperND Nested dissection algorithm, similar to KaHyParBipartite. Requires imporing either KaHyPar or Metis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The KaHyParBipartite is implemented as an extension. If you have issues in installing KaHyPar, please check these issues: #12 and #19. Additionally, code simplifiers can be used to preprocess the tensor network to reduce the optimization time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplifier Description\nMergeVectors Merges vector tensors with their neighbors\nMergeGreedy Greedily merges rank non-increasing tensors","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details about the contraction order optimization, please refer to the contraction order page. Details about the tree width solver can be found in the tree width page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OMEinsumContractionOrders, Graphs, KaHyPar\nfunction random_regular_eincode(n, k; optimize=nothing)\n\tg = Graphs.random_regular_graph(n, k)\n\tixs = [[minmax(e.src,e.dst)...] for e in Graphs.edges(g)]\n\treturn OMEinsumContractionOrders.EinCode([ixs..., [[i] for i in Graphs.vertices(g)]...], Int[])\nend\n    \ncode = random_regular_eincode(100, 3);\ncontraction_complexity(code, uniformsize(code, 2))\n\noptcode_tree = optimize_code(code, uniformsize(code, 2),\n\tTreeSA(sc_target=28, βs=0.1:0.1:10, ntrials=2, niters=100, sc_weight=3.0));\ncontraction_complexity(optcode_tree, uniformsize(code, 2))\n\noptcode_tree_with_slice = optimize_code(code, uniformsize(code, 2),\n\tTreeSA(sc_target=28, βs=0.1:0.1:10, ntrials=2, niters=20, sc_weight=3.0, nslices=5));\n\noptcode_kahypar = optimize_code(code, uniformsize(code, 2), \n\tKaHyParBipartite(sc_target=30, max_group_size=50));\ncontraction_complexity(optcode_kahypar, uniformsize(code, 2))\n\noptcode_sa = optimize_code(code, uniformsize(code, 2),\n\tSABipartite(sc_target=30, max_group_size=50));\ncontraction_complexity(optcode_sa, uniformsize(code, 2))","category":"page"},{"location":"#Example-2:-Use-it-in-OMEinsum","page":"Home","title":"Example 2: Use it in OMEinsum","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OMEinsumContractionOrders is shipped with OMEinsum package. You can use it to optimize the contraction order of an OMEinsum expression.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OMEinsum\n\ncode = ein\"ij, jk, kl, il->\"\n\noptimized_code = optimize_code(code, uniformsize(code, 2), TreeSA())","category":"page"},{"location":"","page":"Home","title":"Home","text":"For multi-GPU contraction of tensor networks, please check this Gist.","category":"page"},{"location":"#Example-3:-Visualization","page":"Home","title":"Example 3: Visualization","text":"","category":"section"},{"location":"#LuxorTensorPlot","page":"Home","title":"LuxorTensorPlot","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LuxorTensorPlot is an extension of the OMEinsumContractionOrders package that provides a visualization of the contraction order. It is designed to work with the OMEinsumContractionOrders package. To use LuxorTensorPlot, please follow these steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add OMEinsumContractionOrders, LuxorGraphPlot\n\njulia> using OMEinsumContractionOrders, LuxorGraphPlot","category":"page"},{"location":"","page":"Home","title":"Home","text":"and then the extension will be loaded automatically.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The extension provides the following to function, viz_eins and viz_contraction, where the former will plot the tensor network as a graph, and the latter will generate a video or gif of the contraction process. Here is an example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OMEinsumContractionOrders, LuxorGraphPlot\n\njulia> eincode = OMEinsumContractionOrders.EinCode([['a', 'b'], ['a', 'c', 'd'], ['b', 'c', 'e', 'f'], ['e'], ['d', 'f']], ['a'])\nab, acd, bcef, e, df -> a\n\njulia> viz_eins(eincode, filename = \"eins.png\")\n\njulia> nested_eins = optimize_code(eincode, uniformsize(eincode, 2), GreedyMethod())\nab, ab -> a\n├─ ab\n└─ acf, bcf -> ab\n   ├─ acd, df -> acf\n   │  ├─ acd\n   │  └─ df\n   └─ bcef, e -> bcf\n      ├─ bcef\n      └─ e\n\n\njulia> viz_contraction(nested_code)\n[ Info: Generating frames, 7 frames in total\n[ Info: Creating video at: /var/folders/3y/xl2h1bxj4ql27p01nl5hrrnc0000gn/T/jl_SiSvrH/contraction.mp4\n\"/var/folders/3y/xl2h1bxj4ql27p01nl5hrrnc0000gn/T/jl_SiSvrH/contraction.mp4\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The resulting image and video will be saved in the current working directory, and the image is shown below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"text-align:center\">\n\t<img src=\"assets/eins.png\" alt=\"Image\" width=\"40%\" />\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"The large white nodes represent the tensors, and the small colored nodes represent the indices, red for closed indices and green for open indices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Bouchitté2001]: Bouchitté, V., Todinca, I., 2001. Treewidth and Minimum Fill-in: Grouping the Minimal Separators. SIAM J. Comput. 31, 212–232. https://doi.org/10.1137/S0097539799359683","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Gray2021]: Gray, Johnnie, and Stefanos Kourtis. \"Hyper-optimized tensor network contraction.\" Quantum 5 (2021): 410.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Kalachev2021]: Kalachev, Gleb, Pavel Panteleev, and Man-Hong Yung. \"Recursive multi-tensor contraction for XEB verification of quantum circuits.\" arXiv preprint arXiv:2108.05665 (2021).","category":"page"}]
}
