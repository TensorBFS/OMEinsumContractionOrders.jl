var documenterSearchIndex = {"docs":
[{"location":"ref/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"Reference","title":"Reference","text":"Pages = [\"ref.md\"]","category":"page"},{"location":"ref/","page":"Reference","title":"Reference","text":"Modules = [OMEinsumContractionOrders]","category":"page"},{"location":"ref/#OMEinsumContractionOrders.ExactTreewidth","page":"Reference","title":"OMEinsumContractionOrders.ExactTreewidth","text":"const ExactTreewidth{GM} = Treewidth{SafeRules{BT, MMW{3}(), MF}, GM}\nExactTreewidth(; greedy_config = GreedyMethod(nrepeat=1)) = Treewidth(; greedy_config)\n\nExactTreewidth is a specialization of Treewidth for the SafeRules preprocessing algorithm with the BT elimination algorithm. The BT algorithm is an exact solver for the treewidth problem that implemented in TreeWidthSolver.jl.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.GreedyMethod","page":"Reference","title":"OMEinsumContractionOrders.GreedyMethod","text":"GreedyMethod{MT}\nGreedyMethod(; α = 0.0, temperature = 0.0, nrepeat=1)\n\nThe fast but poor greedy optimizer. Input arguments are\n\n* `α` is the parameter for the loss function, for pairwise interaction, L = size(out) - α * (size(in1) + size(in2))\n* `temperature` is the parameter for sampling, if it is zero, the minimum loss is selected; for non-zero, the loss is selected by the Boltzmann distribution, given by p ~ exp(-loss/temperature).\n* `nrepeat` is the number of repeatition, returns the best contraction order.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.KaHyParBipartite","page":"Reference","title":"OMEinsumContractionOrders.KaHyParBipartite","text":"KaHyParBipartite{RT,IT,GM}\nKaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),\n    max_group_size=40, greedy_config=GreedyMethod())\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nimbalances is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,\nmax_group_size is the maximum size that allowed to used greedy search,\ngreedy_config is a greedy optimizer.\n\nReferences\n\nHyper-optimized tensor network contraction\nSimulating the Sycamore quantum supremacy circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeGreedy","page":"Reference","title":"OMEinsumContractionOrders.MergeGreedy","text":"MergeGreedy <: CodeSimplifier\nMergeGreedy(; threshhold=-1e-12)\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges tensors greedily if the space complexity of merged tensors is reduced (difference smaller than the threshhold).\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeVectors","page":"Reference","title":"OMEinsumContractionOrders.MergeVectors","text":"MergeVectors <: CodeSimplifier\nMergeVectors()\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges vectors to closest tensors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.SABipartite","page":"Reference","title":"OMEinsumContractionOrders.SABipartite","text":"SABipartite{RT,BT}\nSABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000\n    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsize_dict, a dictionary that specifies leg dimensions,\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nmax_group_size is the maximum size that allowed to used greedy search,\nβs is a list of inverse temperature 1/T,\nniters is the number of iteration in each temperature,\nntrials is the number of repetition (with different random seeds),\nsub_optimizer, the optimizer for the bipartited sub graphs, one can choose GreedyMethod() or TreeSA(),\ninitializer, the partition configuration initializer, one can choose :random or :greedy (slow but better).\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.TreeSA","page":"Reference","title":"OMEinsumContractionOrders.TreeSA","text":"TreeSA{RT,IT,GM}\nTreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,\n    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))\n\nOptimize the einsum contraction pattern using the simulated annealing on tensor expression tree.\n\nsc_target is the target space complexity,\nntrials, βs and niters are annealing parameters, doing ntrials indepedent annealings, each has inverse tempteratures specified by βs, in each temperature, do niters updates of the tree.\nsc_weight is the relative importance factor of space complexity in the loss compared with the time complexity.\nrw_weight is the relative importance factor of memory read and write in the loss compared with the time complexity.\ninitializer specifies how to determine the initial configuration, it can be :greedy or :random. If it is using :greedy method to generate the initial configuration, it also uses two extra arguments greedy_method and greedy_nrepeat.\nnslices is the number of sliced legs, default is 0.\nfixed_slices is a vector of sliced legs, default is [].\n\nReferences\n\nRecursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.Treewidth","page":"Reference","title":"OMEinsumContractionOrders.Treewidth","text":"struct Treewidth{EL <: EliminationAlgorithm, GM} <: CodeOptimizer\nTreewidth(; alg::EL = SafeRules(BT(), MMW{3}(), MF()), greedy_config::GM = GreedyMethod(nrepeat=1))\n\nTree width based solver. The solvers are implemented in CliqueTrees.jl and TreeWidthSolver.jl. They include:\n\nAlgorithm Description Time Complexity Space Complexity\nBFS breadth-first search O(m + n) O(n)\nMCS maximum cardinality search O(m + n) O(n)\nLexBFS lexicographic breadth-first search O(m + n) O(m + n)\nRCMMD reverse Cuthill-Mckee (minimum degree) O(m + n) O(m + n)\nRCMGL reverse Cuthill-Mckee (George-Liu) O(m + n) O(m + n)\nMCSM maximum cardinality search (minimal) O(mn) O(n)\nLexM lexicographic breadth-first search (minimal) O(mn) O(n)\nAMF approximate minimum fill O(mn) O(m + n)\nMF minimum fill O(mn²) -\nMMD multiple minimum degree O(mn²) O(m + n)\n\nDetailed descriptions is available in the CliqueTrees.jl.\n\nFields\n\nalg::EL: The algorithm to use for the treewidth calculation. Available elimination algorithms are listed above.\ngreedy_config::GM: The configuration for the greedy method.\n\nExample\n\njulia> optimizer = Treewidth();\n\njulia> eincode = OMEinsumContractionOrders.EinCode([['a', 'b'], ['a', 'c', 'd'], ['b', 'c', 'e', 'f'], ['e'], ['d', 'f']], ['a'])\nab, acd, bcef, e, df -> a\n\njulia> size_dict = Dict([c=>(1<<i) for (i,c) in enumerate(['a', 'b', 'c', 'd', 'e', 'f'])]...)\nDict{Char, Int64} with 6 entries:\n  'f' => 64\n  'a' => 2\n  'c' => 8\n  'd' => 16\n  'e' => 32\n  'b' => 4\n\njulia> optcode = optimize_code(eincode, size_dict, optimizer)\nab, ab -> a\n├─ fac, bcf -> ab\n│  ├─ df, acd -> fac\n│  │  ├─ df\n│  │  └─ acd\n│  └─ e, bcef -> bcf\n│     ├─ e\n│     └─ bcef\n└─ ab\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.contraction_complexity-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}","page":"Reference","title":"OMEinsumContractionOrders.contraction_complexity","text":"contraction_complexity(eincode, size_dict) -> ContractionComplexity\n\nReturns the time, space and read-write complexity of the einsum contraction. The returned object contains 3 fields:\n\ntime complexity tc defined as log2(number of element-wise multiplications).\nspace complexity sc defined as log2(size of the maximum intermediate tensor).\nread-write complexity rwc defined as log2(the number of read-write operations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.flop-Union{Tuple{VT}, Tuple{LT}, Tuple{OMEinsumContractionOrders.EinCode, Dict{LT, VT}}} where {LT, VT}","page":"Reference","title":"OMEinsumContractionOrders.flop","text":"flop(eincode, size_dict) -> Int\n\nReturns the number of iterations, which is different with the true floating point operations (FLOP) by a factor of 2.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.label_elimination_order-Tuple{OMEinsumContractionOrders.NestedEinsum}","page":"Reference","title":"OMEinsumContractionOrders.label_elimination_order","text":"label_elimination_order(code) -> Vector\n\nReturns a vector of labels sorted by the order they are eliminated in the contraction tree. The contraction tree is specified by code, which e.g. can be a NestedEinsum instance.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_code","page":"Reference","title":"OMEinsumContractionOrders.optimize_code","text":"optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing, permute=true) -> optimized_eincode\n\nOptimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a NestedEinsum instance. Input arguments are\n\neincode is an einsum contraction code instance, one of DynamicEinCode, StaticEinCode or NestedEinsum.\nsize is a dictionary of \"edge label=>edge size\" that contains the size information, one can use uniformsize(eincode, 2) to create a uniform size.\noptimizer is a CodeOptimizer instance, should be one of GreedyMethod, Treewidth, KaHyParBipartite, SABipartite or TreeSA. Check their docstrings for details.\nsimplifier is one of MergeVectors or MergeGreedy.\noptimize the permutation if permute is true.\n\nExamples\n\njulia> using OMEinsum\n\njulia> code = ein\"ij, jk, kl, il->\"\nij, jk, kl, il -> \n\njulia> optimize_code(code, uniformsize(code, 2), TreeSA());\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsumContractionOrders.optimize_greedy-Union{Tuple{T2}, Tuple{TT}, Tuple{TA}, Tuple{L}, Tuple{OMEinsumContractionOrders.EinCode{L}, Dict{L, T2}}} where {L, TA, TT, T2}","page":"Reference","title":"OMEinsumContractionOrders.optimize_greedy","text":"optimize_greedy(eincode, size_dict; α = 0.0, temperature = 0.0, nrepeat=1)\n\nGreedy optimizing the contraction order and return a NestedEinsum object. Check the docstring of tree_greedy for detailed explaination of other input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_kahypar-Tuple{OMEinsumContractionOrders.EinCode, Any}","page":"Reference","title":"OMEinsumContractionOrders.optimize_kahypar","text":"optimize_kahypar(code, size_dict; sc_target, max_group_size=40, imbalances=0.0:0.01:0.2, greedy_method=MinSpaceOut(), greedy_nrepeat=1)\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. size_dict is a dictionary that specifies leg dimensions.  Check the docstring of KaHyParBipartite for detailed explaination of other input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_kahypar_auto-Tuple{OMEinsumContractionOrders.EinCode, Any}","page":"Reference","title":"OMEinsumContractionOrders.optimize_kahypar_auto","text":"optimize_kahypar_auto(code, size_dict; max_group_size=40, sub_optimizer = GreedyMethod())\n\nFind the optimal contraction order automatically by determining the sc_target with bisection. It can fail if the tree width of your graph is larger than 100.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_sa-Tuple{OMEinsumContractionOrders.EinCode, Any}","page":"Reference","title":"OMEinsumContractionOrders.optimize_sa","text":"optimize_sa(code, size_dict; sc_target, max_group_size=40, βs=0.1:0.2:15.0, niters=1000, ntrials=50,\n       sub_optimizer = GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. size_dict is a dictionary that specifies leg dimensions.  Check the docstring of SABipartite for detailed explaination of other input arguments.\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_tree-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}","page":"Reference","title":"OMEinsumContractionOrders.optimize_tree","text":"optimize_tree(code, size_dict; sc_target=20, βs=0.1:0.1:10, ntrials=2, niters=100, sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_method=MinSpaceOut(), fixed_slices=[])\n\nOptimize the einsum contraction pattern specified by code, and edge sizes specified by size_dict. Check the docstring of TreeSA for detailed explaination of other input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.optimize_treewidth-Union{Tuple{EL}, Tuple{GM}, Tuple{Treewidth{EL, GM}, OMEinsumContractionOrders.AbstractEinsum, Dict}} where {GM, EL}","page":"Reference","title":"OMEinsumContractionOrders.optimize_treewidth","text":"optimize_treewidth(optimizer, eincode, size_dict)\n\nOptimizing the contraction order via solve the exact tree width of the line graph corresponding to the eincode and return a NestedEinsum object. Check the docstring of treewidth_method for detailed explaination of other input arguments.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.peak_memory-Tuple{OMEinsumContractionOrders.NestedEinsum, Dict}","page":"Reference","title":"OMEinsumContractionOrders.peak_memory","text":"peak_memory(code, size_dict::Dict) -> Int\n\nEstimate peak memory in number of elements.\n\n\n\n\n\n","category":"method"},{"location":"ref/#OMEinsumContractionOrders.tree_greedy-Union{Tuple{ET}, Tuple{TT}, Tuple{TA}, Tuple{OMEinsumContractionOrders.IncidenceList{Int64, ET}, Any}} where {TA, TT, ET}","page":"Reference","title":"OMEinsumContractionOrders.tree_greedy","text":"tree_greedy(incidence_list, log2_sizes; α = 0.0, temperature = 0.0, nrepeat=1)\n\nCompute greedy order, and the time and space complexities, the rows of the incidence_list are vertices and columns are edges. log2_sizes are defined on edges. α is the parameter for the loss function, for pairwise interaction, L = size(out) - α * (size(in1) + size(in2)) temperature is the parameter for sampling, if it is zero, the minimum loss is selected; for non-zero, the loss is selected by the Boltzmann distribution, given by p ~ exp(-loss/temperature).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OMEinsumContractionOrders","category":"page"},{"location":"#OMEinsumContractionOrders","page":"Home","title":"OMEinsumContractionOrders","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for OMEinsumContractionOrders, a Julia package for the optimization of the contraction order of tensor networks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installation guide is available in README.md. You can also access its features in OMEinsum, which uses it as the default contraction order optimizer.","category":"page"},{"location":"#Example-1:-Use-it-directly","page":"Home","title":"Example 1: Use it directly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The contraction order optimizer is implemented in the optimize_code function. It takes three arguments: code, size, and optimizer. The code argument is the einsum notation to be optimized. The size argument is the size of the variables in the einsum notation. The optimizer argument is the optimizer to be used. The optimize_code function returns the optimized contraction order. One can use contraction_complexity function to get the time, space and rewrite complexity of returned contraction order. Supported solvers include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optimizer Description\nGreedyMethod Fast, but poor resulting order\nTreeSA Reliable, local search based optimizer [Kalachev2021], but is a bit slow\nKaHyParBipartite and SABipartite Graph bipartition based, suited for large tensor networks [Gray2021], requires using KaHyPar package\nTreewidth Tree width solver based, based on package CliqueTrees, performance is elimination algorithm dependent\nExactTreewidth (alias of Treewidth{RuleReduction{BT}}) Exact, but takes exponential time [Bouchitté2001], based on package TreeWidthSolver","category":"page"},{"location":"","page":"Home","title":"Home","text":"The KaHyParBipartite is implemented as an extension. If you have issues in installing KaHyPar, please check these issues: #12 and #19. Additionally, code simplifiers can be used to preprocess the tensor network to reduce the optimization time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplifier Description\nMergeVectors Merges vector tensors with their neighbors\nMergeGreedy Greedily merges rank non-increasing tensors","category":"page"},{"location":"","page":"Home","title":"Home","text":"More details could be found in this blog post.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OMEinsumContractionOrders, Graphs, KaHyPar\nfunction random_regular_eincode(n, k; optimize=nothing)\n\tg = Graphs.random_regular_graph(n, k)\n\tixs = [[minmax(e.src,e.dst)...] for e in Graphs.edges(g)]\n\treturn OMEinsumContractionOrders.EinCode([ixs..., [[i] for i in Graphs.vertices(g)]...], Int[])\nend\n    \ncode = random_regular_eincode(100, 3);\ncontraction_complexity(code, uniformsize(code, 2))\n\noptcode_tree = optimize_code(code, uniformsize(code, 2),\n\tTreeSA(sc_target=28, βs=0.1:0.1:10, ntrials=2, niters=100, sc_weight=3.0));\ncontraction_complexity(optcode_tree, uniformsize(code, 2))\n\noptcode_tree_with_slice = optimize_code(code, uniformsize(code, 2),\n\tTreeSA(sc_target=28, βs=0.1:0.1:10, ntrials=2, niters=20, sc_weight=3.0, nslices=5));\n\noptcode_kahypar = optimize_code(code, uniformsize(code, 2), \n\tKaHyParBipartite(sc_target=30, max_group_size=50));\ncontraction_complexity(optcode_kahypar, uniformsize(code, 2))\n\noptcode_sa = optimize_code(code, uniformsize(code, 2),\n\tSABipartite(sc_target=30, max_group_size=50));\ncontraction_complexity(optcode_sa, uniformsize(code, 2))","category":"page"},{"location":"#Example-2:-Use-it-in-OMEinsum","page":"Home","title":"Example 2: Use it in OMEinsum","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OMEinsumContractionOrders is shipped with OMEinsum package. You can use it to optimize the contraction order of an OMEinsum expression.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OMEinsum\n\ncode = ein\"ij, jk, kl, il->\"\n\noptimized_code = optimize_code(code, uniformsize(code, 2), TreeSA())","category":"page"},{"location":"","page":"Home","title":"Home","text":"For multi-GPU contraction of tensor networks, please check this Gist.","category":"page"},{"location":"#Example-3:-Visualization","page":"Home","title":"Example 3: Visualization","text":"","category":"section"},{"location":"#LuxorTensorPlot","page":"Home","title":"LuxorTensorPlot","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LuxorTensorPlot is an extension of the OMEinsumContractionOrders package that provides a visualization of the contraction order. It is designed to work with the OMEinsumContractionOrders package. To use LuxorTensorPlot, please follow these steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add OMEinsumContractionOrders, LuxorGraphPlot\n\njulia> using OMEinsumContractionOrders, LuxorGraphPlot","category":"page"},{"location":"","page":"Home","title":"Home","text":"and then the extension will be loaded automatically.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The extension provides the following to function, viz_eins and viz_contraction, where the former will plot the tensor network as a graph, and the latter will generate a video or gif of the contraction process. Here is an example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using OMEinsumContractionOrders, LuxorGraphPlot\n\njulia> eincode = OMEinsumContractionOrders.EinCode([['a', 'b'], ['a', 'c', 'd'], ['b', 'c', 'e', 'f'], ['e'], ['d', 'f']], ['a'])\nab, acd, bcef, e, df -> a\n\njulia> viz_eins(eincode, filename = \"eins.png\")\n\njulia> nested_eins = optimize_code(eincode, uniformsize(eincode, 2), GreedyMethod())\nab, ab -> a\n├─ ab\n└─ acf, bcf -> ab\n   ├─ acd, df -> acf\n   │  ├─ acd\n   │  └─ df\n   └─ bcef, e -> bcf\n      ├─ bcef\n      └─ e\n\n\njulia> viz_contraction(nested_code)\n[ Info: Generating frames, 7 frames in total\n[ Info: Creating video at: /var/folders/3y/xl2h1bxj4ql27p01nl5hrrnc0000gn/T/jl_SiSvrH/contraction.mp4\n\"/var/folders/3y/xl2h1bxj4ql27p01nl5hrrnc0000gn/T/jl_SiSvrH/contraction.mp4\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The resulting image and video will be saved in the current working directory, and the image is shown below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"text-align:center\">\n\t<img src=\"assets/eins.png\" alt=\"Image\" width=\"40%\" />\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"The large white nodes represent the tensors, and the small colored nodes represent the indices, red for closed indices and green for open indices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Bouchitté2001]: Bouchitté, V., Todinca, I., 2001. Treewidth and Minimum Fill-in: Grouping the Minimal Separators. SIAM J. Comput. 31, 212–232. https://doi.org/10.1137/S0097539799359683","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Gray2021]: Gray, Johnnie, and Stefanos Kourtis. \"Hyper-optimized tensor network contraction.\" Quantum 5 (2021): 410.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Kalachev2021]: Kalachev, Gleb, Pavel Panteleev, and Man-Hong Yung. \"Recursive multi-tensor contraction for XEB verification of quantum circuits.\" arXiv preprint arXiv:2108.05665 (2021).","category":"page"}]
}
