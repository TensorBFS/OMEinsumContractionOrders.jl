<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Choosing Optimizers · OMEinsumContractionOrders.jl</title><meta name="title" content="Choosing Optimizers · OMEinsumContractionOrders.jl"/><meta property="og:title" content="Choosing Optimizers · OMEinsumContractionOrders.jl"/><meta property="twitter:title" content="Choosing Optimizers · OMEinsumContractionOrders.jl"/><meta name="description" content="Documentation for OMEinsumContractionOrders.jl."/><meta property="og:description" content="Documentation for OMEinsumContractionOrders.jl."/><meta property="twitter:description" content="Documentation for OMEinsumContractionOrders.jl."/><meta property="og:url" content="https://GiggleLiu.github.io/OMEinsumContractionOrders.jl/optimizers/"/><meta property="twitter:url" content="https://GiggleLiu.github.io/OMEinsumContractionOrders.jl/optimizers/"/><link rel="canonical" href="https://GiggleLiu.github.io/OMEinsumContractionOrders.jl/optimizers/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OMEinsumContractionOrders.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background Knowledge</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Choosing Optimizers</a><ul class="internal"><li><a class="tocitem" href="#Sec_GreedyMethod"><span><code>GreedyMethod</code></span></a></li><li><a class="tocitem" href="#Sec_TreeSA"><span><code>TreeSA</code></span></a></li><li><a class="tocitem" href="#Sec_HyperND"><span><code>HyperND</code></span></a></li><li><a class="tocitem" href="#Sec_Bipartite"><span><code>KaHyParBipartite</code> and <code>SABipartite</code></span></a></li><li><a class="tocitem" href="#Sec_ExactTreewidth"><span><code>ExactTreewidth</code></span></a></li><li><a class="tocitem" href="#Sec_Treewidth"><span><code>Treewidth</code></span></a></li><li><a class="tocitem" href="#Exhaustive-Search-(planned)"><span>Exhaustive Search (planned)</span></a></li><li><a class="tocitem" href="#Performance-Benchmark"><span>Performance Benchmark</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../ref/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Choosing Optimizers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Choosing Optimizers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/master/docs/src/optimizers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Choosing-Optimizers"><a class="docs-heading-anchor" href="#Choosing-Optimizers">Choosing Optimizers</a><a id="Choosing-Optimizers-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-Optimizers" title="Permalink"></a></h1><p>Supported solvers include:</p><table><tr><th style="text-align: left">Optimizer</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#Sec_GreedyMethod"><code>GreedyMethod</code></a></td><td style="text-align: left">Fast, but poor contraction order</td></tr><tr><td style="text-align: left"><a href="#Sec_TreeSA"><code>TreeSA</code></a></td><td style="text-align: left">Reliable, local search based optimizer <sup class="footnote-reference"><a id="citeref-Kalachev2021" href="#footnote-Kalachev2021">[Kalachev2021]</a></sup>, but is a bit slow</td></tr><tr><td style="text-align: left"><a href="#Sec_HyperND"><code>HyperND</code></a></td><td style="text-align: left">Nested dissection algorithm, similar to <a href="../ref/#OMEinsumContractionOrders.KaHyParBipartite"><code>KaHyParBipartite</code></a>. Requires importing either <a href="https://github.com/kahypar/KaHyPar.jl"><code>KaHyPar</code></a> or <a href="https://github.com/JuliaSparse/Metis.jl"><code>Metis</code></a>.</td></tr><tr><td style="text-align: left"><a href="#Sec_Bipartite"><code>KaHyParBipartite</code> and <code>SABipartite</code></a></td><td style="text-align: left">Graph bipartition based, suited for large tensor networks <sup class="footnote-reference"><a id="citeref-Gray2021" href="#footnote-Gray2021">[Gray2021]</a></sup>, requires using <a href="https://github.com/kahypar/KaHyPar.jl"><code>KaHyPar</code></a> package. Alternatively, a simulated annealing bipartition method is provided in <a href="../ref/#OMEinsumContractionOrders.SABipartite"><code>SABipartite</code></a>.</td></tr><tr><td style="text-align: left"><a href="#Sec_ExactTreewidth"><code>ExactTreewidth</code></a> (alias of <code>Treewidth{RuleReduction{BT}}</code>)</td><td style="text-align: left">Exact, but takes exponential time <sup class="footnote-reference"><a id="citeref-Bouchitté2001" href="#footnote-Bouchitté2001">[Bouchitté2001]</a></sup>, based on package <a href="https://github.com/ArrogantGao/TreeWidthSolver.jl"><code>TreeWidthSolver</code></a>.</td></tr><tr><td style="text-align: left"><a href="#Sec_Treewidth"><code>Treewidth</code></a></td><td style="text-align: left">Tree width solver based, based on package <a href="https://github.com/AlgebraicJulia/CliqueTrees.jl"><code>CliqueTrees</code></a>, performance is elimination algorithm dependent.</td></tr></table><p>There is a tradeoff between the time and the quality of the contraction order. The following figure shows the Pareto front of the multi-objective optimization of the time to optimize the contraction order and the time to contract the tensor network.</p><p><img src="../assets/tradeoff.svg" alt/></p><p>Among these methods, the <code>ExactTreewidth</code> method produces the lowest treewidth, but it does not scale up to tensor networks with more than 50 tensors. The <code>TreeSA</code> is the second best in terms of the treewidth. It works well in most cases, and supports <a href="../background/#Reduce-space-complexity-by-slicing">slicing</a>. The only limitation is that it is a bit slow. For application sensitive to overhead, the <code>GreedyMethod</code> and <code>Treewidth</code> method (blue region) are recommended. The <code>Treewidth</code> method is a zoo of methods provided by the package <a href="https://github.com/AlgebraicJulia/CliqueTrees.jl"><code>CliqueTrees</code></a>, which is a collection of methods for finding the approximate tree decomposition of a graph. Most of them have similar performance with the <code>GreedyMethod</code>, and most of them are very efficient. The <code>HyperND</code> method has a very good overall performance in benchmarks (to be added), and it is much faster than the <code>TreeSA</code> method. It relies on the <code>KaHyPar</code> package, which is platform picky.</p><h2 id="Sec_GreedyMethod"><a class="docs-heading-anchor" href="#Sec_GreedyMethod"><code>GreedyMethod</code></a><a id="Sec_GreedyMethod-1"></a><a class="docs-heading-anchor-permalink" href="#Sec_GreedyMethod" title="Permalink"></a></h2><p>Implemented as <a href="../ref/#OMEinsumContractionOrders.GreedyMethod"><code>GreedyMethod</code></a> in the package. The Greedy method is one of the simplest and fastest method for optimizing the contraction order. The idea is to greedily select the pair of tensors with the smallest cost to contract at each step. The cost is defined as:</p><p class="math-container">\[L = \text{size}(\text{out}) - α \times (\text{size}(\text{in}_1) + \text{size}(\text{in}_2))\]</p><p>where <span>$\text{out}$</span> is the output tensor, and <span>$\text{in}_1$</span> and <span>$\text{in}_2$</span> are the input tensors. <span>$α$</span> is a hyperparameter, which is set to <span>$0.0$</span> by default, meaning that we greedily select the pair of tensors with the smallest size of the output tensor. For <span>$\alpha = 1$</span>, the size increase in each step is greedily optimized.</p><h2 id="Sec_TreeSA"><a class="docs-heading-anchor" href="#Sec_TreeSA"><code>TreeSA</code></a><a id="Sec_TreeSA-1"></a><a class="docs-heading-anchor-permalink" href="#Sec_TreeSA" title="Permalink"></a></h2><p>Implemented as <a href="../ref/#OMEinsumContractionOrders.TreeSA"><code>TreeSA</code></a> in the package. The local search method <sup class="footnote-reference"><a id="citeref-Kalachev2021" href="#footnote-Kalachev2021">[Kalachev2021]</a></sup> is a heuristic method based on the idea of simulated annealing. The method starts from a random contraction order and then applies the following four possible transforms as shown in the following figure</p><p><img src="../assets/treesa.svg" alt/></p><p>They correspond to the different ways to contract three sub-networks:</p><p class="math-container">\[(A * B) * C = (A * C) * B = (C * B) * A, \\
A * (B * C) = B * (A * C) = C * (B * A),\]</p><p>where we slightly abuse the notation &quot;<span>$*$</span>&quot; to denote the tensor contraction, and <span>$A, B, C$</span> are the sub-networks to be contracted. Due to the commutative property of the tensor contraction, such transformations do not change the result of the contraction. Even through these transformations are simple, all possible contraction orders can be reached from any initial contraction order. The local search method starts from a random contraction tree. In each step, the above rules are randomly applied to transform the tree and then the cost of the new tree is evaluated, which is defined as</p><p class="math-container">\[\mathcal{L} = \text{tc} + w_s \times \text{sc} + w_{\text{rw}} \times \text{rwc},\]</p><p>where <span>$w_s$</span> and <span>$w_{\text{rw}}$</span> are the weights of the space complexity and read-write complexity compared to the time complexity, respectively. The optimal choice of weights depends on the specific device and tensor contraction algorithm. One can freely tune the weights to achieve a best performance for their specific problem. Then the transformation is accepted with a probability given by the Metropolis criterion, which is</p><p class="math-container">\[p_{\text{accept}} = \min(1, e^{-\beta \Delta \mathcal{L}}),\]</p><p>where <span>$\beta$</span> is the inverse temperature, and <span>$\Delta \mathcal{L}$</span> is the difference of the cost of the new and old contraction trees. During the process, the temperature is gradually decreased, and the process stop when the temperature is low enough. Additionally, the <code>TreeSA</code> method supports the slicing technique. When the space complexity is too large, one can loop over a subset of indices, and then contract the intermediate results in the end. Such technique can reduce the space complexity, but slicing <span>$n$</span> indices will increase the time complexity by <span>$2^n$</span>.</p><h2 id="Sec_HyperND"><a class="docs-heading-anchor" href="#Sec_HyperND"><code>HyperND</code></a><a id="Sec_HyperND-1"></a><a class="docs-heading-anchor-permalink" href="#Sec_HyperND" title="Permalink"></a></h2><p>Implemented as <a href="../ref/#OMEinsumContractionOrders.HyperND"><code>HyperND</code></a> in the package.</p><h2 id="Sec_Bipartite"><a class="docs-heading-anchor" href="#Sec_Bipartite"><code>KaHyParBipartite</code> and <code>SABipartite</code></a><a id="Sec_Bipartite-1"></a><a class="docs-heading-anchor-permalink" href="#Sec_Bipartite" title="Permalink"></a></h2><p>Implemented as <a href="../ref/#OMEinsumContractionOrders.KaHyParBipartite"><code>KaHyParBipartite</code></a> and <a href="../ref/#OMEinsumContractionOrders.SABipartite"><code>SABipartite</code></a> in the package. These two methods are based on the graph bipartition, </p><p class="math-container">\[\min \sum_{e \in \text{cut}}\omega(e)\\
\text{s.t.} \quad c(V_i) \leq (1+\epsilon) \left\lceil \frac{c(V)}{2} \right\rceil.\]</p><p>where <span>$\text{cut}$</span> is the set of hyperedges cut by the partition, <span>$\omega(e)$</span> is the weight of the hyperedge <span>$e$</span>, <span>$V_i$</span> is the <span>$i$</span>-th part of the partition, <span>$c(V)$</span> is the node weight of the partition, and <span>$\epsilon$</span> is the imbalance parameter. It tries to minimize the cut crossing two blocks, while the size of each block is balanced. The algorithm is implemented in the package <a href="https://github.com/kahypar/KaHyPar.jl">KaHyPar.jl</a><sup class="footnote-reference"><a id="citeref-Schlag2021" href="#footnote-Schlag2021">[Schlag2021]</a></sup>, and the implementation in <a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContractionOrders.jl</a> is mainly based on it.</p><img src="https://cloud.githubusercontent.com/assets/484403/25314222/3a3bdbda-2840-11e7-9961-3bbc59b59177.png" alt="alt text" width="50%" height="50%"><img src="https://cloud.githubusercontent.com/assets/484403/25314225/3e061e42-2840-11e7-860c-028a345d1641.png" alt="alt text" width="50%" height="50%"><p>The <code>KaHyPar</code> binary still have some issues in installation, please refer to <a href="https://github.com/kahypar/KaHyPar.jl/issues/12">#12</a> and <a href="https://github.com/kahypar/KaHyPar.jl/issues/19">#19</a>. The <a href="../ref/#OMEinsumContractionOrders.SABipartite"><code>SABipartite</code></a> is a simulated annealing based alternative to <a href="../ref/#OMEinsumContractionOrders.KaHyParBipartite"><code>KaHyParBipartite</code></a>, it can produce similar results while being much more costly.</p><p>Note: Benchmarks (to be added) show that the later implementation of <a href="../ref/#OMEinsumContractionOrders.HyperND"><code>HyperND</code></a> method is better and faster. These two methods are no longer the first choice.</p><h2 id="Sec_ExactTreewidth"><a class="docs-heading-anchor" href="#Sec_ExactTreewidth"><code>ExactTreewidth</code></a><a id="Sec_ExactTreewidth-1"></a><a class="docs-heading-anchor-permalink" href="#Sec_ExactTreewidth" title="Permalink"></a></h2><p>Implemented as <a href="../ref/#OMEinsumContractionOrders.ExactTreewidth"><code>ExactTreewidth</code></a> in the package. This method is supported by the <a href="https://summerofcode.withgoogle.com">Google Summer of Code 2024</a> project <a href="https://summerofcode.withgoogle.com/programs/2024/projects/B8qSy9dO">&quot;Tensor network contraction order optimization and visualization&quot;</a> released by <strong>The Julia Language</strong>. In this project, we developed <a href="https://github.com/ArrogantGao/TreeWidthSolver.jl">TreeWidthSolver.jl</a>, which implements the Bouchitté–Todinca algorithm<sup class="footnote-reference"><a id="citeref-Bouchitté2001" href="#footnote-Bouchitté2001">[Bouchitté2001]</a></sup>. It later becomes a backend of <a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContracionOrders.jl</a>.</p><p>The Bouchitté–Todinca (BT) algorithm <sup class="footnote-reference"><a id="citeref-Bouchitté2001" href="#footnote-Bouchitté2001">[Bouchitté2001]</a></sup> is a method for calculating the treewidth of a graph exactly. It makes use of the theory of minimal triangulations, characterizing the minimal triangulations of a graph via objects called minimal separators and potential maximal cliques of the graph. The BT algorithm has a time complexity of <span>$O(|\Pi|nm)$</span>, which are dependent on the graph structure. (TODO: add more details of the algorithm complexity, what is it suited for?).</p><p>The blog post <a href="https://arrogantgao.github.io/blogs/treewidth/">Finding the Optimal Tree Decomposition with Minimal Treewidth - Xuan-Zhao Gao</a> has a more detailed description of this method.</p><h2 id="Sec_Treewidth"><a class="docs-heading-anchor" href="#Sec_Treewidth"><code>Treewidth</code></a><a id="Sec_Treewidth-1"></a><a class="docs-heading-anchor-permalink" href="#Sec_Treewidth" title="Permalink"></a></h2><p>Implemented as <a href="../ref/#OMEinsumContractionOrders.Treewidth"><code>Treewidth</code></a> in the package.</p><h2 id="Exhaustive-Search-(planned)"><a class="docs-heading-anchor" href="#Exhaustive-Search-(planned)">Exhaustive Search (planned)</a><a id="Exhaustive-Search-(planned)-1"></a><a class="docs-heading-anchor-permalink" href="#Exhaustive-Search-(planned)" title="Permalink"></a></h2><p>The exhaustive search <sup class="footnote-reference"><a id="citeref-Robert2014" href="#footnote-Robert2014">[Robert2014]</a></sup> is a method to get the exact optimal contraction complexity. There are three different ways to implement the exhaustive search:</p><ul><li><strong>Depth-first constructive approach</strong>: in each step, choose a pair of tensors to contract a new tensor until all tensors are contracted, and then iterate over all possible contraction sequences without duplication. Note the cheapest contraction sequence thus found.</li><li><strong>Breadth-first constructive approach</strong>: the breadth-first method construct the set of intermediate tensors by contracting <span>$c$</span> tensors (<span>$c \in [1, n - 1]$</span>, where <span>$n$</span> is the number of tensors) in each step, and record the optimal cost for constructing each intermediate tensor. Then in the last step, the optimal cost for contracting all <span>$n$</span> tensors is obtained.</li><li><strong>Dynamic programming</strong>: in each step, consider all bipartition that split the tensor network into two parts, if the optimal cost for each part is not recorded, further split them until the cost has been already obtained or only one tensor is left. Then combine the two parts and record the optimal cost of contracting the sub-networks. In this end the optimal cost for the whole network is obtained.</li></ul><p>In more recent work <sup class="footnote-reference"><a id="citeref-Robert2014" href="#footnote-Robert2014">[Robert2014]</a></sup>, by reordering the search process in favor of cheapest-first and excluding large numbers of outer product contractions which are shown to be unnecessary, the efficiency of the exhaustive search has been greatly improved. The method has been implemented in <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a>.</p><h2 id="Performance-Benchmark"><a class="docs-heading-anchor" href="#Performance-Benchmark">Performance Benchmark</a><a id="Performance-Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Benchmark" title="Permalink"></a></h2><h3 id="Compare-ExactTreewidth-and-exhaustive-search"><a class="docs-heading-anchor" href="#Compare-ExactTreewidth-and-exhaustive-search">Compare <code>ExactTreewidth</code> and exhaustive search</a><a id="Compare-ExactTreewidth-and-exhaustive-search-1"></a><a class="docs-heading-anchor-permalink" href="#Compare-ExactTreewidth-and-exhaustive-search" title="Permalink"></a></h3><p>The following figure shows a comparison with the exhaustive search in TensorOperations.jl:</p><p><img src="https://github.com/ArrogantGao/TreeWidthSolver_benchmark/blob/main/figs/compare_TO.png?raw=true" alt/></p><p>The results shown that the tree width based solver is faster for some graph similar to trees. For more details, please see the benchmark repo: <a href="https://github.com/ArrogantGao/TreeWidthSolver_benchmark">https://github.com/ArrogantGao/TreeWidthSolver_benchmark</a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Bouchitté2001"><a class="tag is-link" href="#citeref-Bouchitté2001">Bouchitté2001</a>Bouchitté, V., Todinca, I., 2001. Treewidth and Minimum Fill-in: Grouping the Minimal Separators. SIAM J. Comput. 31, 212–232. https://doi.org/10.1137/S0097539799359683</li><li class="footnote" id="footnote-Gray2021"><a class="tag is-link" href="#citeref-Gray2021">Gray2021</a>Gray, Johnnie, and Stefanos Kourtis. &quot;Hyper-optimized tensor network contraction.&quot; Quantum 5 (2021): 410.</li><li class="footnote" id="footnote-Kalachev2021"><a class="tag is-link" href="#citeref-Kalachev2021">Kalachev2021</a>Kalachev, Gleb, Pavel Panteleev, and Man-Hong Yung. &quot;Recursive multi-tensor contraction for XEB verification of quantum circuits.&quot; arXiv preprint arXiv:2108.05665 (2021).</li><li class="footnote" id="footnote-Robert2014"><a class="tag is-link" href="#citeref-Robert2014">Robert2014</a>Pfeifer, R.N.C., Haegeman, J., Verstraete, F., 2014. Faster identification of optimal contraction sequences for tensor networks. Phys. Rev. E 90, 033315. https://doi.org/10.1103/PhysRevE.90.033315</li><li class="footnote" id="footnote-Schlag2021"><a class="tag is-link" href="#citeref-Schlag2021">Schlag2021</a>Schlag, S., Heuer, T., Gottesbüren, L., Akhremtsev, Y., Schulz, C., Sanders, P., 2021. High-Quality Hypergraph Partitioning. https://doi.org/10.48550/arXiv.2106.08696</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../ref/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Sunday 22 June 2025 14:14">Sunday 22 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
